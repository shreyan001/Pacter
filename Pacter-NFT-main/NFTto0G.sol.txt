// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;
  
  import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
  import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
  
  /**
   * @title ETH-to-NFT Escrow Contract
   * @dev P2P transactions using ETH through escrow for NFTs.
   */
  contract ETH2NFTEscrow is ReentrancyGuard {
      struct EscrowOrder {
          address partyA;
          address partyB;
          address nftContract;
          uint256 nftTokenId;
          uint256 ethAmount;
          bool partyADeposited;
          bool partyBDeposited;
          bool executed;
      }
  
      mapping(uint256 => EscrowOrder) public escrowOrders;
      uint256 public nextOrderId;
  
      event EscrowOrderCreated(
          uint256 indexed orderId,
          address indexed partyA,
          address indexed partyB,
          address nftContract,
          uint256 nftTokenId,
          uint256 ethAmount
      );
  
      event PartyADeposit(uint256 indexed orderId, address indexed partyA);
      event PartyBDeposit(uint256 indexed orderId, address indexed partyB);
      event EscrowExecuted(uint256 indexed orderId);
      event EscrowCancelled(uint256 indexed orderId);
  
      modifier validContract(address _nftContract) {
          require(_nftContract.code.length > 0, "Invalid NFT contract");
          _;
      }
  
      modifier onlyParties(uint256 orderId) {
          EscrowOrder storage order = escrowOrders[orderId];
          require(
              msg.sender == order.partyA || msg.sender == order.partyB,
              "Not authorized"
          );
          _;
      }
  
      modifier notExecuted(uint256 orderId) {
          require(!escrowOrders[orderId].executed, "Already executed");
          _;
      }
  
      function createEscrowOrder(
          address _partyB,
          address _nftContract,
          uint256 _nftTokenId,
          uint256 _ethAmount
      ) external validContract(_nftContract) {
          EscrowOrder storage order = escrowOrders[nextOrderId];
          order.partyA = msg.sender;
          order.partyB = _partyB;
          order.nftContract = _nftContract;
          order.nftTokenId = _nftTokenId;
          order.ethAmount = _ethAmount;
          order.partyADeposited = false;
          order.partyBDeposited = false;
          order.executed = false;
  
          emit EscrowOrderCreated(
              nextOrderId,
              msg.sender,
              _partyB,
              _nftContract,
              _nftTokenId,
              _ethAmount
          );
          nextOrderId++;
      }
  
      function depositETHByPartyA(uint256 orderId) external payable nonReentrant onlyParties(orderId) {
          EscrowOrder storage order = escrowOrders[orderId];
          require(!order.executed, "Already executed");
          require(!order.partyADeposited, "Already deposited");
          require(msg.value == order.ethAmount, "Incorrect ETH amount");
  
          order.partyADeposited = true;
          emit PartyADeposit(orderId, msg.sender);
      }
  
      function depositNFTByPartyB(uint256 orderId) external nonReentrant onlyParties(orderId) {
          EscrowOrder storage order = escrowOrders[orderId];
          require(!order.executed, "Already executed");
          require(!order.partyBDeposited, "Already deposited");
  
          IERC721(order.nftContract).safeTransferFrom(
              msg.sender,
              address(this),
              order.nftTokenId
          );
  
          order.partyBDeposited = true;
          emit PartyBDeposit(orderId, msg.sender);
      }
  
      function executeTransaction(uint256 orderId) external nonReentrant onlyParties(orderId) {
          EscrowOrder storage order = escrowOrders[orderId];
          require(order.partyADeposited, "PartyA has not deposited");
          require(order.partyBDeposited, "PartyB has not deposited");
          require(!order.executed, "Already executed");
  
          (bool success, ) = order.partyB.call{value: order.ethAmount}("");
          require(success, "ETH transfer failed");
  
          IERC721(order.nftContract).safeTransferFrom(
              address(this),
              order.partyA,
              order.nftTokenId
          );
  
          order.executed = true;
          emit EscrowExecuted(orderId);
      }
  
      function cancelEscrow(uint256 orderId) external nonReentrant onlyParties(orderId) {
          EscrowOrder storage order = escrowOrders[orderId];
          require(!order.executed, "Cannot cancel executed order");
  
          if (order.partyADeposited) {
              (bool success, ) = order.partyA.call{value: order.ethAmount}("");
              require(success, "ETH refund failed");
          }
  
          if (order.partyBDeposited) {
              IERC721(order.nftContract).transfer(order.partyB, order.nftTokenId);
          }
  
          delete escrowOrders[orderId];
          emit EscrowCancelled(orderId);
      }
  }`,
      category: "escrow"
    },
    {
      name: "NFT20Escrow Contract",
      description: "This smart contract facilitates secure peer-to-peer exchanges between Non-Fungible Tokens (NFTs) and ERC20 tokens. It acts as a trustless intermediary, ensuring both parties fulfill their commitments before the exchange is completed. For example, Alice can use this contract to safely trade her rare digital artwork NFT for Bob's USDT tokens without the risk of either party backing out mid-transaction. The contract holds both assets in escrow until both parties have made their deposits, after which the exchange can be executed, or cancelled if needed, providing a safe and efficient way to swap any NFT for ERC20 tokens.",
      contract_code: `// SPDX-License-Identifier: MIT
  pragma solidity 0.8.27;
  
  import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
  import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
  
  /**
   * @title NFT-ERC20 Escrow Contract
   * @dev P2P NFT transactions using an ERC20 token (like USDT) through escrow.
   */
  contract NFT20Escrow is ReentrancyGuard {
      struct EscrowOrder {
          address partyA; 
          address partyB; 
          address erc20Contract;
          address nftContract;
          uint256 erc20Amount;
          uint256 nftTokenId;
          bool partyADeposited;
          bool partyBDeposited;
          bool executed;
      }
  
      mapping(uint256 => EscrowOrder) public escrowOrders; // Named mapping for better clarity
      uint256 public nextOrderId;
  
      event EscrowOrderCreated(
          uint256 indexed orderId,
          address indexed partyA,
          address indexed partyB,
          address erc20Contract,
          address nftContract,
          uint256 nftTokenId
      );
  
      event PartyADeposit(uint256 indexed orderId, address indexed partyA);
      event PartyBDeposit(uint256 indexed orderId, address indexed partyB);
      event EscrowExecuted(uint256 indexed orderId);
      event EscrowCancelled(uint256 indexed orderId);
  
      modifier validContracts(address _erc20Contract, address _nftContract) {
          require(_erc20Contract.code.length > 0, "Invalid ERC20 contract");
          require(_nftContract.code.length > 0, "Invalid NFT contract");
          _;
      }
  
      modifier onlyParties(uint256 orderId) {
          EscrowOrder storage order = escrowOrders[orderId];
          require(
              msg.sender == order.partyA || msg.sender == order.partyB,
              "Not authorized"
          );
          _;
      }
  
      modifier notExecuted(uint256 orderId) {
          require(!escrowOrders[orderId].executed, "Already executed");
          _;
      }
  
      function createEscrowOrder(
          address _partyB,
          address _erc20Contract,
          uint256 _erc20Amount,
          address _nftContract,
          uint256 _nftTokenId
      ) external validContracts(_erc20Contract, _nftContract) {
          require(_erc20Amount != 0, "ERC20 amount must be non-zero");
  
          // Cache storage variables in memory
          address partyB = _partyB;
          address erc20Contract = _erc20Contract;
  
          // Use the cached variables
          EscrowOrder storage order = escrowOrders[nextOrderId];
          order.partyA = msg.sender;
          order.partyB = partyB;
          order.erc20Contract = erc20Contract;
          order.erc20Amount = _erc20Amount;
          order.nftContract = _nftContract;
          order.nftTokenId = _nftTokenId;
          order.partyADeposited = false;
          order.partyBDeposited = false;
          order.executed = false;
  
          emit EscrowOrderCreated(
              nextOrderId,
              msg.sender,
              partyB,
              erc20Contract,
              _nftContract,
              _nftTokenId
          );
          nextOrderId++;
      }
  
      function depositERC20(uint256 orderId) external onlyParties(orderId) nonReentrant {
          EscrowOrder storage order = escrowOrders[orderId];
          require(!order.executed, "Already executed");
          require(!order.partyADeposited, "Already deposited");
  
          bool success = IERC20(order.erc20Contract).transferFrom(
              msg.sender,
              address(this),
              order.erc20Amount
          );
          require(success, "ERC20 transfer failed");
  
          order.partyADeposited = true;
          emit PartyADeposit(orderId, msg.sender);
      }
  
      function depositNFT(uint256 orderId) external onlyParties(orderId) nonReentrant {
          EscrowOrder storage order = escrowOrders[orderId];
          require(!order.executed, "Already executed");
          require(!order.partyBDeposited, "Already deposited");
  
          IERC721(order.nftContract).safeTransferFrom(
              msg.sender,
              address(this),
              order.nftTokenId
          );
  
          order.partyBDeposited = true;
          emit PartyBDeposit(orderId, msg.sender);
      }
  
      function executeTransaction(uint256 orderId) external onlyParties(orderId) nonReentrant {
          EscrowOrder storage order = escrowOrders[orderId];
          require(order.partyADeposited, "PartyA has not deposited");
          require(order.partyBDeposited, "PartyB has not deposited");
          require(!order.executed, "Already executed");
  
          bool success = IERC20(order.erc20Contract).transfer(order.partyB, order.erc20Amount);
          require(success, "ERC20 transfer failed");
  
          IERC721(order.nftContract).safeTransferFrom(
              address(this),
              order.partyA,
              order.nftTokenId
          );
  
          order.executed = true;
          emit EscrowExecuted(orderId);
      }
  
      function cancelEscrow(uint256 orderId) external onlyParties(orderId) nonReentrant {
          EscrowOrder storage order = escrowOrders[orderId];
          require(!order.executed, "Cannot cancel executed order");
  
          if (order.partyADeposited) {
              bool success = IERC20(order.erc20Contract).transfer(order.partyA, order.erc20Amount);
              require(success, "ERC20 refund failed");
          }
  
          if (order.partyBDeposited) {
              IERC721(order.nftContract).safeTransferFrom(
                  address(this),
                  order.partyB,
                  order.nftTokenId
              );
          }
  
          delete escrowOrders[orderId];
          emit EscrowCancelled(orderId);
      }
  }